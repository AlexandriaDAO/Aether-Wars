// // Mixing Custom Types and Serde/ciborium
// use ic_cdk_macros::{query, update};
// use ic_stable_structures::StableBTreeMap;
// use serde::{Deserialize, Serialize};
// use std::cell::RefCell;
// use ciborium::value::Value;
// use ciborium::{de::from_reader, ser::into_writer};
// mod memory;
// use memory::Memory;


// #[derive(Serialize, Deserialize, Clone, Debug, candid::CandidType)]
// pub struct MessageCard {
//     pub user_query: String,
//     pub message: String,
// }

// #[derive(Serialize, Deserialize)]
// struct State {
//     #[serde(skip, default = "init_stable_data")]
//     stable_data: StableBTreeMap<u128, (u128, u128), Memory>,
//     #[serde(skip, default = "init_message_cards")]
//     message_cards: StableBTreeMap<String, Vec<u8>, Memory>,
// }

// thread_local! {
//     static STATE: RefCell<State> = RefCell::new(State::default());
// }

// #[query]
// fn stable_get(key: u128) -> Option<(u128, u128)> {
//     STATE.with(|s| s.borrow().stable_data.get(&key))
// }

// #[update]
// fn stable_insert(key: u128, value1: u128, value2: u128) -> Option<(u128, u128)> {
//     STATE
//         .with(|s| s.borrow_mut().stable_data.insert(key, (value1, value2)))
// }

// fn init_stable_data() -> StableBTreeMap<u128, (u128, u128), Memory> {
//     StableBTreeMap::init(crate::memory::get_stable_btree_memory())
// }

// fn init_message_cards() -> StableBTreeMap<String, Vec<u8>, Memory> {
//     StableBTreeMap::init(crate::memory::get_stable_btree_memory())
// }

// impl Default for State {
//     fn default() -> Self {
//         Self {
//             stable_data: init_stable_data(),
//             message_cards: init_message_cards(),
//         }
//     }
// }

// #[update]
// fn save_message_card(user_query: String, message: String) {
//     let card = MessageCard { user_query: user_query.clone(), message };
//     let mut serialized_card = Vec::new();
//     into_writer(&card, &mut serialized_card).expect("Serialization failed");
//     STATE.with(|s| s.borrow_mut().message_cards.insert(user_query, serialized_card));
// }

// #[query]
// fn get_message_card(user_query: String) -> Option<MessageCard> {
//     STATE.with(|s| {
//         s.borrow().message_cards.get(&user_query)
//             .and_then(|bytes| {
//                 let reader = bytes.as_slice();
//                 from_reader(reader).ok()
//             })
//     })
// }

// #[ic_cdk::query]
// fn mc_front(user_query: String) -> Option<MessageCard> {
//     Some(MessageCard {
//         user_query,
//         message: "This is a response generated by a LLM using the results from the semantic search as input, and instructions to summarize.".to_string(),
//     })
// }









// // Done with OG with pure custom types.
// use candid::{CandidType, Deserialize, Encode, Decode};
// use ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};
// use ic_stable_structures::{
//     storable::Bound, DefaultMemoryImpl, StableBTreeMap, Storable,
// };
// use std::{borrow::Cow, cell::RefCell};


// type Memory = VirtualMemory<DefaultMemoryImpl>;

// const MAX_MESSAGE_CARD_SIZE: u32 = 1000;

// #[derive(CandidType, Deserialize)]
// struct MessageCard {
//     user_query: String,
//     message: String,
// }

// impl Storable for MessageCard {
//     fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
//         Cow::Owned(Encode!(self).unwrap())
//     }

//     fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
//         Decode!(bytes.as_ref(), Self).unwrap()
//     }

//     const BOUND: Bound = Bound::Bounded {
//         max_size: MAX_MESSAGE_CARD_SIZE,
//         is_fixed_size: false,
//     };
// }

// thread_local! {
//     static MEMORY_MANAGER: RefCell<MemoryManager<DefaultMemoryImpl>> =
//         RefCell::new(MemoryManager::init(DefaultMemoryImpl::default()));

//     static STABLE_DATA: RefCell<StableBTreeMap<u128, (u128, u128), Memory>> = RefCell::new(
//         StableBTreeMap::init(
//             MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(1))),
//         )
//     );

//     static MESSAGE_CARDS: RefCell<StableBTreeMap<String, MessageCard, Memory>> = RefCell::new(
//         StableBTreeMap::init(
//             MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(2))),
//         )
//     );
// }

// struct State {
//     stable_data: StableBTreeMap<u128, (u128, u128), Memory>,
//     message_cards: StableBTreeMap<String, MessageCard, Memory>,
// }

// impl State {
//     fn init_stable_data() -> StableBTreeMap<u128, (u128, u128), Memory> {
//         StableBTreeMap::init(MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(1))))
//     }

//     fn init_message_cards() -> StableBTreeMap<String, MessageCard, Memory> {
//         StableBTreeMap::init(MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(2))))
//     }
// }

// impl Default for State {
//     fn default() -> Self {
//         Self {
//             stable_data: State::init_stable_data(),
//             message_cards: State::init_message_cards(),
//         }
//     }
// }

// #[ic_cdk_macros::query]
// fn stable_get(key: u128) -> Option<(u128, u128)> {
//     STABLE_DATA.with(|data| data.borrow().get(&key))
// }

// #[ic_cdk_macros::update]
// fn stable_insert(key: u128, value1: u128, value2: u128) -> Option<(u128, u128)> {
//     STABLE_DATA.with(|data| data.borrow_mut().insert(key, (value1, value2)))
// }

// #[ic_cdk_macros::update]
// fn save_message_card(user_query: String, message: String) {
//     let card = MessageCard { user_query: user_query.clone(), message };
//     MESSAGE_CARDS.with(|cards| cards.borrow_mut().insert(user_query, card));
// }

// #[ic_cdk_macros::query]
// fn get_message_card(user_query: String) -> Option<MessageCard> {
//     MESSAGE_CARDS.with(|cards| cards.borrow().get(&user_query))
// }












use candid::{CandidType, Deserialize, Encode, Decode};
use ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};
use ic_stable_structures::{
    storable::Bound, DefaultMemoryImpl, StableBTreeMap, Storable,
};
use std::borrow::Cow;
use std::cell::RefCell;


type Memory = VirtualMemory<DefaultMemoryImpl>;

const MAX_MESSAGE_CARD_SIZE: u32 = 1000;

#[derive(CandidType, Deserialize)]
struct MessageCard {
    user_query: String,
    message: String,
    likes: u128,
    bookmarks: u128,
}

impl Storable for MessageCard {
    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
        Cow::Owned(Encode!(self).unwrap())
    }

    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
        Decode!(bytes.as_ref(), Self).unwrap()
    }

    const BOUND: Bound = Bound::Bounded {
        max_size: MAX_MESSAGE_CARD_SIZE,
        is_fixed_size: false,
    };
}

thread_local! {
    static MEMORY_MANAGER: RefCell<MemoryManager<DefaultMemoryImpl>> =
        RefCell::new(MemoryManager::init(DefaultMemoryImpl::default()));

    static STABLE_DATA: RefCell<StableBTreeMap<u128, (u128, u128), Memory>> = RefCell::new(
        StableBTreeMap::init(
            MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(1))),
        )
    );

    static MESSAGE_CARDS: RefCell<StableBTreeMap<String, MessageCard, Memory>> = RefCell::new(
        StableBTreeMap::init(
            MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(2))),
        )
    );
}

struct State {
    stable_data: StableBTreeMap<u128, (u128, u128), Memory>,
    message_cards: StableBTreeMap<String, MessageCard, Memory>,
}

impl State {
    fn init_stable_data() -> StableBTreeMap<u128, (u128, u128), Memory> {
        StableBTreeMap::init(MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(1))))
    }

    fn init_message_cards() -> StableBTreeMap<String, MessageCard, Memory> {
        StableBTreeMap::init(MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(2))))
    }
}

impl Default for State {
    fn default() -> Self {
        Self {
            stable_data: State::init_stable_data(),
            message_cards: State::init_message_cards(),
        }
    }
}

#[ic_cdk_macros::update]
fn save_message_card(user_query: String, message: String, likes: u128, bookmarks: u128) {
    let card = MessageCard {
        user_query: user_query.clone(),
        message,
        likes,
        bookmarks,
    };
    MESSAGE_CARDS.with(|cards| cards.borrow_mut().insert(user_query, card));
}

#[ic_cdk_macros::query]
fn get_message_card(user_query: String) -> Option<MessageCard> {
    MESSAGE_CARDS.with(|cards| cards.borrow().get(&user_query))
}


























// // OG

// pub mod book_card;
// pub mod message_card;
// pub mod author_card;
// pub mod types;



// use serde::Deserialize;
// extern crate serde;

// #[derive(Clone, Debug, candid::CandidType, serde::Deserialize)]
// pub struct MessageCard {
//     pub user_query: String,
//     pub message: String,
// }

// #[ic_cdk::query]
// fn mc_front(user_query: String) -> Option<MessageCard> {
//     Some(MessageCard {
//         user_query,
//         message: "This is a response generated by a LLM using the results from the semantic search as input, and instructions to summarize.".to_string(),
//     })
// }








// // quickstart example of StableBTreeMap, can be used in production storking k:v pairs.

// use ic_cdk_macros::{query, update};
// use ic_stable_structures::{StableBTreeMap};
// use serde::{Deserialize, Serialize};
// use std::cell::RefCell;
// mod memory;
// use memory::Memory;

// // The state of the canister.
// #[derive(Serialize, Deserialize)]
// struct State {
//     // An example `StableBTreeMap`. Data stored in `StableBTreeMap` doesn't need to
//     // be serialized/deserialized in upgrades, so we tell serde to skip it.
//     #[serde(skip, default = "init_stable_data")]
//     stable_data: StableBTreeMap<u128, u128, Memory>,
// }

// thread_local! {
//     static STATE: RefCell<State> = RefCell::new(State::default());
// }

// // Retrieves the value associated with the given key in the stable data if it exists.
// #[query]
// fn stable_get(key: u128) -> Option<u128> {
//     STATE.with(|s| s.borrow().stable_data.get(&key))
// }

// // Inserts an entry into the map and returns the previous value of the key from stable data
// // if it exists.
// #[update]
// fn stable_insert(key: u128, value: u128) -> Option<u128> {
//     STATE
//         .with(|s| s.borrow_mut().stable_data.insert(key, value))
// }

// fn init_stable_data() -> StableBTreeMap<u128, u128, Memory> {
//     StableBTreeMap::init(crate::memory::get_stable_btree_memory())
// }

// impl Default for State {
//     fn default() -> Self {
//         Self {
//             stable_data: init_stable_data(),
//         }
//     }
// }










// // Storing two vectors instead of one

// use ic_cdk_macros::{query, update};
// use ic_stable_structures::{StableBTreeMap};
// use serde::{Deserialize, Serialize};
// use std::cell::RefCell;
// mod memory;
// use memory::Memory;

// #[derive(Serialize, Deserialize)]
// struct State {
//     #[serde(skip, default = "init_stable_data")]
//     stable_data: StableBTreeMap<u128, (u128, u128), Memory>,
// }

// thread_local! {
//     static STATE: RefCell<State> = RefCell::new(State::default());
// }

// #[query]
// fn stable_get(key: u128) -> Option<(u128, u128)> {
//     STATE.with(|s| s.borrow().stable_data.get(&key))
// }

// #[update]
// fn stable_insert(key: u128, value1: u128, value2: u128) -> Option<(u128, u128)> {
//     STATE
//         .with(|s| s.borrow_mut().stable_data.insert(key, (value1, value2)))
// }

// fn init_stable_data() -> StableBTreeMap<u128, (u128, u128), Memory> {
//     StableBTreeMap::init(crate::memory::get_stable_btree_memory())
// }

// impl Default for State {
//     fn default() -> Self {
//         Self {
//             stable_data: init_stable_data(),
//         }
//     }
// }


// // First step is probably going to be just inserting a second value to the k/v pair.
// // Then'll be inserting it as two types.
// // Then'll be applying to my existing message card.
// // Then'll be adding a proper ID.





// // Custom types example (User Profile)
// use candid::{CandidType, Decode, Deserialize, Encode};
// use ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};
// use ic_stable_structures::{
//     storable::Bound, DefaultMemoryImpl, StableBTreeMap, Storable,
// };
// use std::{borrow::Cow, cell::RefCell};

// type Memory = VirtualMemory<DefaultMemoryImpl>;

// const MAX_VALUE_SIZE: u32 = 100;

// #[derive(CandidType, Deserialize)]
// struct UserProfile {
//     age: u8,
//     name: String,
// }

// // For a type to be used in a `StableBTreeMap`, it needs to implement the `Storable`
// // trait, which specifies how the type can be serialized/deserialized.
// //
// // In this example, we're using candid to serialize/deserialize the struct, but you
// // can use anything as long as you're maintaining backward-compatibility. The
// // backward-compatibility allows you to change your struct over time (e.g. adding
// // new fields).
// //
// // The `Storable` trait is already implemented for several common types (e.g. u64),
// // so you can use those directly without implementing the `Storable` trait for them.
// impl Storable for UserProfile {
//     fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
//         Cow::Owned(Encode!(self).unwrap())
//     }

//     fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
//         Decode!(bytes.as_ref(), Self).unwrap()
//     }

//     const BOUND: Bound = Bound::Bounded {
//         max_size: MAX_VALUE_SIZE,
//         is_fixed_size: false,
//     };
// }

// thread_local! {
//     // The memory manager is used for simulating multiple memories. Given a `MemoryId` it can
//     // return a memory that can be used by stable structures.
//     static MEMORY_MANAGER: RefCell<MemoryManager<DefaultMemoryImpl>> =
//         RefCell::new(MemoryManager::init(DefaultMemoryImpl::default()));

//     static MAP: RefCell<StableBTreeMap<u64, UserProfile, Memory>> = RefCell::new(
//         StableBTreeMap::init(
//             MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(0))),
//         )
//     );
// }

// /// Retrieves the value associated with the given key if it exists.
// #[ic_cdk_macros::query]
// fn get(key: u64) -> Option<UserProfile> {
//     MAP.with(|p| p.borrow().get(&key))
// }

// #[ic_cdk_macros::update]
// fn insert(key: u64, value: UserProfile) -> Option<UserProfile> {
//     MAP.with(|p| p.borrow_mut().insert(key, value))
// }






















// // Logical strucutre/ideas for later.

// use ic_cdk::export::candid::{CandidType};
// use ic_cdk::api::management_canister::http_request::{HttpHeader, HttpMethod, HttpResponse};
// use ic_cdk::export::candid::Nat;
// use ic_cdk_macros::*;
// use serde_json::json;

// #[derive(Clone, Debug, Default, CandidType)]
// pub struct SocialStats {
//     pub likes: u32,
//     pub stars: u32,
//     pub avg_rating: u32,
//     pub num_ratings: u32,
//     pub num_flags: u32,
//     pub bookmarks: u32,
// }

// #[derive(Clone, Debug, Default, CandidType)]
// pub struct BookCard {
//     pub id: u64;
//     pub title: String,
//     pub author: String,
//     pub heading: String,
//     pub message: String,
//     pub summary: String,
//     pub content: String,
//     pub stats: SocialStats,
// }

// pub struct BookCardActor {
//     book_cards: Vec<BookCard>,
// }

// impl BookCardActor {
//     // Initialize with some default data
//     pub fn new() -> Self {
//         let default_card = BookCard {
//             title: String::from("Sample Title"),
//             author: String::from("Sample Author"),
//             heading: String::from("Sample Heading"),
//             summary: String::from("Sample Summary"),
//             content: String::from("Sample Content"),
//             stats: SocialStats::default(),
//         };

//         Self {
//             book_cards: vec![default_card.clone(), default_card.clone(), default_card],
//         }
//     }

//     #[query]
//     pub fn get_book_cards(&self) -> HttpResponse {
//         let body = serde_json::to_string(&self.book_cards).unwrap_or_else(|_| "Error converting to JSON".to_string());

//         HttpResponse {
//             status: Nat::from(200),
//             headers: vec![HttpHeader {
//                 name: "Content-Type".to_string(),
//                 value: "application/json".to_string(),
//             }],
//             body: body.as_bytes().to_vec(),
//         }
//     }
// }

// #[init]
// fn init() {
//     let actor = BookCardActor::new();
//     ic_cdk::storage::put(actor);
// }
